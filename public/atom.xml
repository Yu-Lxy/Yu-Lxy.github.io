<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LXYu.♡</title>
  
  <subtitle>˙ ᵕ ˙ 這是我的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-04T04:04:15.783Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>鲤小鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue+koa+mysql实现一个简单的todolist</title>
    <link href="http://yoursite.com/2020/09/03/koa/"/>
    <id>http://yoursite.com/2020/09/03/koa/</id>
    <published>2020-09-03T02:41:27.000Z</published>
    <updated>2020-09-04T04:04:15.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>构建一个数据通过 <code>koa</code> 的api获取，页面通过 <code>vue</code> 渲染的前后端都有的完整demo。包括一个登陆页面和一个todolist页面的增删改查，其中用到了前端 <code>Vue框架</code> 、<code>koa</code> 提供接口、验证 <code>token</code>、<code>sequelize</code> 操作 <code>mysql</code> 等，这里记录一些关键点。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这里用到的是vue-cli2的webpack，项目创建好之后执行<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn </span><br><span class="line">yarn <span class="keyword">add </span>koa koa-router koa-logger koa-<span class="keyword">json </span>koa-<span class="keyword">bodyparser </span>nodemon vue-router element-ui axios koa-<span class="keyword">jwt </span><span class="keyword">bcrypt </span>kao-static</span><br></pre></td></tr></table></figure></p><blockquote><p>在根目录下创建server文件夹，及子文件夹</p><ul><li>config（数据库配置）</li><li>controllers（控制层，根据页面的请求选取”数据层”中相应的数据，然后返回给页面）</li><li>models（数据层，将数据库和表结构连起来）</li><li>routes（路由）</li><li>schema（表结构）</li></ul></blockquote><blockquote><p>在根目录下创建app.js作为koa的启动文件（具体代码见项目）</p></blockquote><p>后端：在控制台输入 <code>nodemon app.js</code>, 输出<code>Koa is listening in 8889</code>说明启动成功，并在8889端口监听。<br>前端：在控制台输入 <code>npm run dev</code> 后在 <code>localhost:8080</code> 可以展示前端页面。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>可以去官网下载<code>mysql</code>，我用到的可视化工具是<code>MySQLWorkbench</code></p><p>安装好后开始创建数据表。用户表：用于登录验证。待办事项表用于展示待办事项。</p><p>user表：</p><table><thead><tr><th>字段</th><th>类型</th></tr></thead><tbody><tr><td>id(用戶id)</td><td>int(自增)</td></tr><tr><td>user_name(用户名)</td><td>CHAR(50)</td></tr><tr><td>password(密码)</td><td>CHAR(128)</td></tr></tbody></table><p>—</p><p>list表：</p><table><thead><tr><th>字段</th><th>类型</th></tr></thead><tbody><tr><td>id(list的id)</td><td>int(自增)</td></tr><tr><td>user_id(用户id)</td><td>int(11)</td></tr><tr><td>content(代办内容)</td><td>CHAR(255)</td></tr><tr><td>status(代办状态)</td><td>tinyint(1)</td></tr></tbody></table><p>—</p><h2 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h2><p><code>sequelize</code> 理解为用简单的方式操作数据库的ORM框架。</p><p><code>server/schema</code> 下新建两个文件，user.js和list.js，是数据库的两张表结构，可使用sequelize-auto直接导出表结构。</p><p>在<code>server/config</code>下新建db.js, 用于初始化Sequelize和数据库的连接（具体代码见项目）</p><h2 id="JSON-WEB-TOKEN"><a href="#JSON-WEB-TOKEN" class="headerlink" title="JSON-WEB-TOKEN"></a>JSON-WEB-TOKEN</h2><p>运用了JSON-WEB-TOKEN的登录系统应该是这样的：</p><blockquote><ol><li>用户在登录页输入账号密码，将账号密码（加密后）发送请求给后端</li><li>后端验证一下用户的账号和密码的信息，如果符合就发一个token返回给客户端，如果不符合就不发送token，返回验证错误信息。</li><li>如果登录成功，客户端将token用某种方式存下来，之后要请求其他资源的时候，在请求头里带上这个token。</li><li>后端收到请求信息，先验证下token是否有效，有效则下发请求的资源，无效则返回验证错误。</li></ol></blockquote><p>通过这个token的方式，客户端和服务端之间的访问，是无状态的。也就是服务端不知道你这个用户到底在不在线，只要你发送的请求头里的token是正确的我就给你返回你想要的资源。这样能够不占用服务端的空间资源，而且如果涉及到服务器集群，如果服务器进行维护或者迁移或者需要CDN节点的分配的话，<code>无状态</code>的设计显然维护成本更低。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用法 --&gt;</span></span><br><span class="line"></span><br><span class="line">const secret = 'vue-koa-demo' // 指定密钥，这是之后用来判断token合法性的标志</span><br><span class="line"></span><br><span class="line">jwt.sign(userToken, secret) // 签发token</span><br><span class="line"></span><br><span class="line">jwt.decode(token) // 解析token</span><br></pre></td></tr></table></figure><h2 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h2><p>md5加密容易被破解，所以准备采用<code>bcrypt</code>的加密方式，全部走后端加密。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证密码是否正确</span></span><br><span class="line">bcrypt.compareSync(data<span class="selector-class">.password</span>, userInfo.password)</span><br></pre></td></tr></table></figure></p><h2 id="Token的发送与验证"><a href="#Token的发送与验证" class="headerlink" title="Token的发送与验证"></a>Token的发送与验证</h2><p>在全局发送请求<code>Header</code>上加入<code>Authorization</code>属性， 值是<code>Bearer token值</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue<span class="selector-class">.prototype</span>.<span class="variable">$http</span><span class="selector-class">.defaults</span><span class="selector-class">.headers</span><span class="selector-class">.common</span>[<span class="string">'Authorization'</span>] = <span class="string">'Bearer '</span> + token</span><br></pre></td></tr></table></figure></p><p>/api/* 都需要走token验证<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">koa</span><span class="selector-class">.use</span>(<span class="string">"/api"</span>,jwt(&#123;<span class="attribute">secret</span>: <span class="string">'vue-koa-demo'</span>&#125;),api.routes()) <span class="comment">// 所有走/api/打头的请求都需要经过jwt中间件的验证。secret密钥必须跟我们当初签发的secret一致</span></span><br></pre></td></tr></table></figure></p><h2 id="Koa-serve静态资源"><a href="#Koa-serve静态资源" class="headerlink" title="Koa serve静态资源"></a>Koa serve静态资源</h2><p>项目<code>npm run dev</code>打包后<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serve = <span class="keyword">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(serve(path.join(__dirname, <span class="string">'dist'</span>))) <span class="comment">// 将webpack打包好的项目目录作为Koa静态文件服务的目录</span></span><br></pre></td></tr></table></figure></p><p>这样不用启前端项目，localhost:8889就可以访问打包好的静态资源页面。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>这是一个前后端都有的完整小demo，结构清晰简单的小东西更容易理解和入门，完整项目<a href="https://github.com/Yu-Lxy/Daily_practice/tree/master/koa" target="_blank" rel="noopener">Github地址</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;构建一个数据通过 &lt;code&gt;koa&lt;/code&gt; 的api获取，页面通过 &lt;code&gt;vue&lt;/code&gt; 渲染的前后端都有的完整demo。包括一个登陆页面和一个todolist页面的增删改查，其中用到了前端 &lt;code&gt;Vue框架&lt;/code&gt; 、&lt;code&gt;koa&lt;/code&gt; 提供接口、验证 &lt;code&gt;token&lt;/code&gt;、&lt;code&gt;sequelize&lt;/code&gt; 操作 &lt;code&gt;mysql&lt;/code&gt; 等，这里记录一些关键点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>try catch能捕获到哪些JS异常</title>
    <link href="http://yoursite.com/2020/08/04/tryCatch/"/>
    <id>http://yoursite.com/2020/08/04/tryCatch/</id>
    <published>2020-08-04T01:50:45.000Z</published>
    <updated>2020-09-04T02:00:54.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写代码时经常会用到 <code>try catch</code>，防止一些JS报错，导致页面挂掉。那么到底哪些JS异常能被捕获到呢？</p></blockquote><a id="more"></a><blockquote><p><strong>简单解释就是：在报错的时候，线程执行已经进入 <code>try catch</code> 代码块，并且处在 <code>try catch</code> 里，才能被捕捉到。</strong>（之前，之后都无法捕捉异常）</p></blockquote><ul><li><h6 id="下面三个小栗子，解释一下-try-catch-的前中后"><a href="#下面三个小栗子，解释一下-try-catch-的前中后" class="headerlink" title="下面三个小栗子，解释一下 try catch 的前中后"></a>下面三个小栗子，解释一下 <code>try catch</code> 的前中后</h6></li></ul><p>🌰 例子1：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a(</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Unexpected token &#125;</span><br></pre></td></tr></table></figure></p><p><em>例子1</em> 语法异常（SyntaxError），因为语法异常是在语法阶段就报错了，所以线程还没进入 <code>try catch</code> 代码块，就捕获不到异常。</p><p>🌰 例子2：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function d () &#123;a.b&#125;</span><br><span class="line">try &#123;</span><br><span class="line">   d()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">   console.log('error', e)</span><br><span class="line">&#125;</span><br><span class="line">// output</span><br><span class="line"><span class="keyword">error </span>ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p><p><em>例子2</em> 报错的时机，是代码执行进入了 <code>try catch</code> ，执行 d 方法的时候，线程执行处在 <code>try</code> 里面，所以能捕捉到。</p><p>🌰 例子3：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   function d () &#123;a.b&#125;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">   console.log('error', e)</span><br><span class="line">&#125;</span><br><span class="line">d()</span><br><span class="line">// output</span><br><span class="line"><span class="keyword">error </span>ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p><p><em>例子3</em> 方法定义在 <code>try catch</code> 代码块里，但是执行方法在 <code>try catch</code> 外，执行 d 方法的时候报错，此时 try catch 已经执行完成，所以无法捕捉异常。</p><p>三个例子之后应该能理解怎样的JS异常可以被捕获了，但是在我们用 <code>promise</code> 的时候发现相对于外部的 <code>try catch</code> ，Promise 没有异常！</p><h3 id="promise-amp-try-catch"><a href="#promise-amp-try-catch" class="headerlink" title="promise &amp; try catch"></a>promise &amp; try catch</h3><p>🌰 例子4：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    a.b</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>(v)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">ReferenceError</span>: a is not defined</span><br></pre></td></tr></table></figure></p><p><em>例子4</em> 线程在执行a.b的时候，适时向属于同步执行，<code>try catch</code> 并未执行完成，为什么捕获不到异常呢？</p><p>事实上，<strong>Promise 的异常都是由 reject 和 Promise.prototype.catch 来捕获</strong>，不管是同步还是异步。</p><p>核心原因是因为 <code>Promise</code> 在执行回调中都用 <code>try catch</code> 包裹起来了，其中所有的异常都被内部捕获到了，并未往上抛异常，所以异常都不会被外层的 <code>try catch</code> 捕捉。</p><p>🌰 例子5：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'报错了'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> a()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">error 报错了</span><br></pre></td></tr></table></figure></p><p>为什么 <em>例子5</em> 的异常能被 <code>catch</code> 捕获到呢，因为报错的时候，线程执行已经进入了 <code>try catch</code> 代码块，并且异常由 reject 抛出，自然可以捕获到。</p><p> ###总结：</p><blockquote><p><strong>1. 在报错的时候，线程执行已经进入 <code>try catch</code> 代码块，并且处在 <code>try catch</code> 里，才能被捕捉到。</strong></p></blockquote><blockquote><p><strong>2. 不要用 <code>try catch</code> 包裹 <code>Promise</code>，我们只需要给 <code>Promise</code> 增加 Promise#catch 就 OK 了</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写代码时经常会用到 &lt;code&gt;try catch&lt;/code&gt;，防止一些JS报错，导致页面挂掉。那么到底哪些JS异常能被捕获到呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>EventLoop 的简单理解</title>
    <link href="http://yoursite.com/2020/07/28/eventLoop/"/>
    <id>http://yoursite.com/2020/07/28/eventLoop/</id>
    <published>2020-07-28T02:13:09.000Z</published>
    <updated>2020-09-04T02:15:23.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="EventLoop是什么"><a href="#EventLoop是什么" class="headerlink" title="EventLoop是什么"></a>EventLoop是什么</h3><blockquote><p>一个循环 每次循环叫tick 每次循环的代码叫task</p></blockquote><ul><li>V8引擎单线程无法同时干两件事</li><li>文件读取、网络IO缓慢且具有不确定性</li><li>要通过异步回调方式处理又称为异步IO</li><li>先同步再异步 异步放入队列等同步完成后再执行 每次循环叫一个tick(process.nextTick())</li></ul><a id="more"></a><h3 id="异步任务的区分"><a href="#异步任务的区分" class="headerlink" title="异步任务的区分"></a>异步任务的区分</h3><p>microtasks(微任务)：</p><blockquote><p>唯一，整个事件循环中仅存在一个；执行为同步，同一个事件循环中的microtasks会按队列顺序串行执行完毕</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe</li><li>MutationObserver</li></ul></blockquote><p>macrotask(宏任务)：</p><ul><li>setTimeout</li><li>serInterval</li><li>setImmediate</li><li>I/O</li><li>UI渲染</li></ul><blockquote><p>先执行微任务 再执行宏任务</p></blockquote><p>如果遇到async的代码 await后面的程序就挂起 类似于微任务 等到后面的同步任务执行完了再执行</p><p>最后上一个小栗子🌰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'promise then ...'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"fun start"</span>)</span><br><span class="line">  <span class="keyword">const</span> aa = <span class="keyword">await</span> <span class="number">1</span> <span class="comment">// 到这里挂起，后面先不执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"fun end"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout 放入event table中 1秒后将回调函数放入宏任务的event queue中</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout ...'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick ...'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console ...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">resolve</span><br><span class="line">fun start</span><br><span class="line"><span class="built_in">console</span> ...</span><br><span class="line">nextTick ...</span><br><span class="line">promise then ...</span><br><span class="line">fun end</span><br><span class="line">setTimeout ...</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;EventLoop是什么&quot;&gt;&lt;a href=&quot;#EventLoop是什么&quot; class=&quot;headerlink&quot; title=&quot;EventLoop是什么&quot;&gt;&lt;/a&gt;EventLoop是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个循环 每次循环叫tick 每次循环的代码叫task&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;V8引擎单线程无法同时干两件事&lt;/li&gt;
&lt;li&gt;文件读取、网络IO缓慢且具有不确定性&lt;/li&gt;
&lt;li&gt;要通过异步回调方式处理又称为异步IO&lt;/li&gt;
&lt;li&gt;先同步再异步 异步放入队列等同步完成后再执行 每次循环叫一个tick(process.nextTick())&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue+vue-ueditor-wrap+秀米</title>
    <link href="http://yoursite.com/2019/09/03/xiumi/"/>
    <id>http://yoursite.com/2019/09/03/xiumi/</id>
    <published>2019-09-03T09:44:15.000Z</published>
    <updated>2020-09-04T01:53:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>我们的项目中使用的是ueditor+秀米的富文本编辑器，github上的大神做了一个基于vue的ueditor的组件，能够实现双向数据绑定，可以不用费劲的getContent、setContent。就决定用这个组件 ——  <a href="https://github.com/HaoChuan9421/vue-ueditor-wrap" target="_blank" rel="noopener">vue-ueditor-wrap</a>    。so~  vue+vue-ueditor-wrap+秀米. 开始吧 ⤵︎</p><a id="more"></a><p><strong>一：去ueditor官网下载官方源码</strong> </p><ol><li><p><a href="https://ueditor.baidu.com/website/download.html" target="_blank" rel="noopener">https://ueditor.baidu.com/website/download.html</a></p></li><li><p>下载完成后，放到你的Vue项目里static下并命名为UEditor。</p></li></ol><p><strong>二：安装vue-ueditor-wrap</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-ueditor-wrap</span><br></pre></td></tr></table></figure><p><strong>三：引入并使用</strong> </p><ol><li><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="comment">// 引入ueditor的依赖文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/ueditor.config'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/ueditor.all.min.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/lang/zh-cn/zh-cn.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/ueditor.parse.min.js'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">  &lt;!--数据绑定--&gt;</span><br><span class="line">    &lt;vue-ueditor-wrap v-model=<span class="string">"msg"</span> /&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import VueUeditorWrap from 'vue-ueditor-wrap' /</span><span class="regexp">/ 引入vue-ueditor-wrap</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'HelloWorld',</span></span><br><span class="line"><span class="regexp">  components: &#123;</span></span><br><span class="line"><span class="regexp">    VueUeditorWrap/</span><span class="regexp">/注册组件</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      msg: 'Welcome to Your Vue.js App'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些完成后，你就可以看到一个初始化好的<code>ueditor</code>了，并且可以很方便的绑定想要的数据 ?<br>接入<strong>秀米</strong>的童鞋继续向下看?</p><p><strong>四：在ueditor基础上接入秀米</strong></p><p>秀米提供：<a href="http://hgs.xiumi.us/uedit/" target="_blank" rel="noopener">秀米图文排版UEditor插件示例</a></p><ol><li><p>在你的index.html中引用 <code>http://xiumi.us/connect/ue/xiumi-ue-dialog-v5.js</code> 和 <code>http://xiumi.us/connect/ue/xiumi-ue-v5.css</code> 也可以下载文件后放在UEditor目录下引入本地文件，这样方便修改。（我是下载后引入本地的）如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"static/UEditor/xiumi-ue-v5.css"</span>&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"static/UEditor/xiumi-ue-dialog-v5.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>下载文件 <code>http://xiumi.us/connect/ue/xiumi-ue-dialog-v5.html</code> 和 <code>http://hgs.xiumi.us/uedit/dialogs/internal.js</code> 放在你的UEditor目录下。</p></li><li><p>修改<code>UEditor</code>的配置（ueditor.config.js），第414行左右：将section:[] 改为section:[‘class’, ‘style’]，避免ueditor修改秀米的格式信息，造成排版错误。</p></li><li><p>在<code>xiumi-ue-dialog-v5.js</code>中把<code>iframeUrl</code>改为本地秀米H5的路径，如果你都是按照以上步骤进行那么路径将是<code>/static/UEditor/xiumi-ue-dialog-v5.html</code>，如果不是的话要按你自己的路径。</p></li></ol><p>到这里就是可以正常使用秀米并且有着双向数据绑定的ueditor啦。<br>图片上传相关功能需要后台小哥哥的协助。<br>其余与秀米的对接可以参考<a href="http://ent.xiumi.us/" target="_blank" rel="noopener">与秀米对接</a><br>还是有疑问的小盆友可以下载我上传的<a href="https://github.com/Yu-Lxy/vue-ueditor-wrap-xiumi" target="_blank" rel="noopener">demo</a>，希望可以帮助到你😜</p><p>这是接好后的样纸：<br><img src="/2019/09/03/xiumi/1599127298698.jpg" alt="秀米"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的项目中使用的是ueditor+秀米的富文本编辑器，github上的大神做了一个基于vue的ueditor的组件，能够实现双向数据绑定，可以不用费劲的getContent、setContent。就决定用这个组件 ——  &lt;a href=&quot;https://github.com/HaoChuan9421/vue-ueditor-wrap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-ueditor-wrap&lt;/a&gt;    。so~  vue+vue-ueditor-wrap+秀米. 开始吧 ⤵︎&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://yoursite.com/2019/03/01/buildHexo/"/>
    <id>http://yoursite.com/2019/03/01/buildHexo/</id>
    <published>2019-03-01T09:32:15.000Z</published>
    <updated>2020-09-04T02:35:57.146Z</updated>
    
    <content type="html"><![CDATA[<p>第一次看到这种类型的博客就赶脚逼格很高的样纸 😎</p><p>后来试着搭起来觉得并不困难 ☁️</p><p>简单来说hexo就是一个静态页面生成和创建的工具</p><p>这篇教你搭建一个自己的hexo博客 👉</p><a id="more"></a><h3 id="我的搭建步骤有以下："><a href="#我的搭建步骤有以下：" class="headerlink" title="我的搭建步骤有以下："></a>我的搭建步骤有以下：</h3><ul><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>生成SSH添加到GitHub</li><li>将hexo部署到GitHub</li></ul><h3 id="1-安装git和node"><a href="#1-安装git和node" class="headerlink" title="1.安装git和node"></a>1.安装git和node</h3><p>git和node是必备条件, 可以戳：<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰大神的git教程</a><br><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">下载node</a></p><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>git和node安好之后，接下来就是安hexo了<br>1.可以先新建一个文件夹，例🌰:我的是myBlog<br>进到这个文件夹内，打开命令行<br>2.Windows的小伙伴可以直接用 <code>npm install -g hexo</code><br>mac的小伙伴需要用 <code>sudo npm install --unsafe-perm --verbose -g hexo</code><br>完成之后可以 <code>hexo -v</code> 查看hexo版本<br>3.接下来初始化hexo <code>hexo init</code><br>完成之后会在myBlog生成以下文件：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>node_modules：</td><td>是依赖包</td></tr><tr><td>public：</td><td>生成的静态文件，这个目录最终会发布到服务器</td></tr><tr><td>scaffolds：</td><td>命令生成文章等的模板</td></tr><tr><td>source：</td><td>编写的markdown文件，_drafts草稿文件，_posts发布的文章</td></tr><tr><td>themes：</td><td>主题</td></tr><tr><td>_config.yml：</td><td>整个博客的配置</td></tr><tr><td>package.json：</td><td>项目所需模块项目的配置信息</td></tr></tbody></table><p>我们正常使用，修改最多的源码是 <code>_config.yml</code> 文件，不管是博客的基础配置，还是模板，都是修改这个文件。<br><code>source</code> 是我们日常写文章要用的目录，是我们日常操作的文件夹。<br>如果要修改主题模板，就需要操作 <code>themes</code>.</p><p>4.接下来<br><code>hexo g</code><br><code>hexo s</code><br>就可以在本地 <code>http://localhost:4000</code> 预览了<br><code>ctrl+c</code> 或是 <code>control+c</code> 关闭本地服务</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>没有github账号需要先注册一个哦<br>有账号就新建一个库：<br><img src="/2019/03/01/buildHexo/hexo1.jpg" alt="Create a new repository"><br>建一个和你的username一样名字的库，比如我的就是这样：<br><img src="/2019/03/01/buildHexo/hexo2.jpg" alt><br>点击create repository</p><h3 id="生成SSH添加到GitHub-mac"><a href="#生成SSH添加到GitHub-mac" class="headerlink" title="生成SSH添加到GitHub(mac)"></a>生成SSH添加到GitHub(mac)</h3><p>1.检查是否已经存在SSH Key<br>打开电脑终端，输入 <code>ls -al ~/.ssh</code><br>2.如果终端出现文件id_rsa.pub 或 id_dsa.pub，则表示该电脑已经存在SSH Key，此时可继续输入<br><code>cat ~/.ssh/id_rsa.pub</code><br>复制接下来显示出来的一大串内容<br>3.如果终端未出现id_rsa.pub 或 id_dsa.pub文件，表示该电脑还没有配置SSH Key，此时需要输<br><code>ssh-keygen -t rsa -C &quot;your_full_name@xxxxx.com&quot;</code><br>连续回车即可，也可能会让你输入密码，密码就是你的开机密码<br>创建完成后按照第二步操作复制就行啦<br>这时候去到GitHub的setting<img src="/2019/03/01/buildHexo/hexo3.jpg" alt><br>再点击SSH and GPG keys<img src="/2019/03/01/buildHexo/hexo4.jpg" alt><br>点击New SSH key之后吧你刚刚复制的一串key粘在这里面 点击Add SSH key就ok啦<br><img src="/2019/03/01/buildHexo/hexo5.jpg" alt></p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>完成这一步就可以把你的hexo部署到github上辣<br>1.首先在你的项目文件下找到 <code>_config.yml</code> 进去找到<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/YourgithubName/YourgithubName.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p><p>把这个地址改成你专属的，比如我的是：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">repo:</span> <span class="string">https:</span><span class="comment">//github.com/Yu-Lxy/Yu-Lxy.github.io</span></span><br></pre></td></tr></table></figure></p><p>*注：这里有个坑🕳，一定要在冒号后面加一个空格，不然 <code>hexo d</code> 的时候会没有反应</p><p>2.需要安装deploy-git,也就是部署的命令,这样你才能用命令部署到GitHub:<br><code>npm install hexo-deployer-git --save</code><br>3.然后<br><code>hexo g</code><br><code>hexo d</code><br>输入 <code>http://yourname.github.io</code> 就能看到你的hexo咯~😆</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次看到这种类型的博客就赶脚逼格很高的样纸 😎&lt;/p&gt;
&lt;p&gt;后来试着搭起来觉得并不困难 ☁️&lt;/p&gt;
&lt;p&gt;简单来说hexo就是一个静态页面生成和创建的工具&lt;/p&gt;
&lt;p&gt;这篇教你搭建一个自己的hexo博客 👉&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
