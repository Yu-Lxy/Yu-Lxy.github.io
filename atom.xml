<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LXYu.♡</title>
  
  <subtitle>˙ ᵕ ˙ 這是我的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-09T06:27:37.420Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>鲤小鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后台管理系统element-admin——登录权限篇</title>
    <link href="http://yoursite.com/2020/09/08/element-admin/"/>
    <id>http://yoursite.com/2020/09/08/element-admin/</id>
    <published>2020-09-08T06:47:37.000Z</published>
    <updated>2020-09-09T06:27:37.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>记录写后台管理系统时的一些想法和组件的二次封装，项目初期参考的是<a href="https://github.com/PanJiaChen" target="_blank" rel="noopener">花裤衩</a>大神的<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a>，后期根据业务进行了一些修改。</p><blockquote><p><a href="https://github.com/Yu-Lxy/element-admin" target="_blank" rel="noopener">项目Github地址</a></p></blockquote><a id="more"></a><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录流程的思路我们先屡清楚：</p><ul><li><p>用户在登录页输入账号密码，将账号密码发送请求给后端</p><ul><li><p>将账号密码发送请求给后端的方法写在<code>vuex</code>里便于全局token的存取，而前端登录方法里只需要关注登录的结果，并根据结果跳转页面或提示错误，这样代码结构会清晰。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- action: --&gt;</span><br><span class="line"></span><br><span class="line">Login (&#123;commit&#125;, userInfo) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = userInfo</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    login(&#123; <span class="attr">username</span>: username.trim(), <span class="attr">password</span>: password &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.event !== <span class="number">0</span>) &#123;</span><br><span class="line">          reject(res)</span><br><span class="line">        &#125;</span><br><span class="line">        Vue.ls.set(ACCESS_TOKEN, res.data.token, <span class="number">12</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">        commit(<span class="string">'SET_TOKEN'</span>, res.data.token)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch (<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- Login页面: --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([<span class="string">'Login'</span>]),</span><br><span class="line">  handleLogin () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.loginForm.validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.Login(<span class="keyword">this</span>.loginForm)</span><br><span class="line">          .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="keyword">this</span>.redirect || <span class="string">'/'</span> &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">            <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">          &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.$message.error(err.message);</span><br><span class="line">            <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error submit!!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>后端验证一下用户的账号和密码的信息，如果符合就发一个token返回给客户端，如果不符合就不发送token，返回验证错误信息。</p></li><li>如果登录成功，客户端将<code>token</code>存在<code>localStorage</code>里，之后要请求其他资源的时候，在请求头里带上这个token。<ul><li><code>service/http.js</code> 中全局请求拦截器中：<code>config.headers[&#39;token&#39;] = token</code>。</li></ul></li><li>后端收到请求信息，先验证下token是否有效，有效则下发请求的资源，无效则返回验证错误。</li></ul><h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><p>登录成功之后，在全局路由钩子<code>router.beforeEach</code>中拦截路由，判断如果有token，就去获取用户信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- router.beforeEach --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Vue.ls.get(ACCESS_TOKEN)) &#123;</span><br><span class="line">  store.dispatch(<span class="string">'GetInfo'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">infoRes</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> roles = res.data.role;</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>权限控制是很常见的需求，我们的业务要求控制到按钮级别。</p><blockquote><p>页面级权限的实现方式是通过获取当前用户的权限去对比路由表，生成当前用户具有权限可访问的路由表，通过 <code>router.addRouters</code> 挂载到 <code>router</code> 上。</p></blockquote><p><strong>具体步骤如下：</strong></p><ol><li>判断是否有<code>token</code>，如果没有就去登录，有就第二步。</li><li>获取用户信息 <code>store.dispatch(&#39;GetInfo&#39;)</code>。</li><li>获取信息成功之后，调用<code>store.dispatch(&#39;GenerateRoutes&#39;)</code>，这个方法里会调用/router/index.js里的 <code>generatorDynamicRouter</code> 方法，并返回一个根据用户信息构建好权限的路由结构。（generatorDynamicRouter方法里将后台返回的一个平级的menu信息，通过递归的方式生成层级结构，再递归生成层级路由）</li><li>将构建的路由结构信息利用 <code>Vue-Router</code> 提供的动态增加路由方法 <code>router.addRoutes</code> 加入到路由表中。</li><li>加入路由表后将页面跳转到用户原始要访问的页面,如果没有 <code>redirect</code> 则进入默认页面。</li></ol><blockquote><p>我们把 <code>登录</code> 和 <code>获取用户信息</code> 分成了两个接口，原因是当用户刷新页面时，可以根据登录时获取到的token去获取用户信息，避免了刷新还要调用登录接口。</p></blockquote><p>整体流程可以看这个图：<br><img src="/2020/09/08/element-admin/permission.png" alt="promission"></p><h3 id="前端控制权限"><a href="#前端控制权限" class="headerlink" title="前端控制权限"></a>前端控制权限</h3><p>旧版本后台的路由表是后端同学根据权限生成的，这使得前端小伙伴每开发一个页面就需要让后端同学配一下路由和权限，光听着就开始皱眉了🤦‍♀️。</p><p>于是我们采用了在前端页面配置路由和权限，之后将这份路由表存到后端。</p><p>权限/菜单：<br><img src="/2020/09/08/element-admin/permission1.png" alt></p><p>权限/角色：<br><img src="/2020/09/08/element-admin/permission2.png" alt></p><blockquote><p><strong>一角色对应多权限，一用户对应多角色</strong></p></blockquote><blockquote><p>当用户登录后得到 <code>roles</code>，前端根据 roles 去向后端请求可访问的路由表，从而动态生成可访问页面，之后就是 <code>router.addRoutes</code> 动态挂载到 <code>router</code> 上，和原来是相同的。</p></blockquote><h3 id="按钮级权限"><a href="#按钮级权限" class="headerlink" title="按钮级权限"></a>按钮级权限</h3><p>在配置菜单权限页面也可以添加配置按钮的权限，登录之后的 <code>store.dispatch(&#39;GetInfo&#39;)</code> 中能拿到对应权限的按钮，并存储在 <code>vuex</code> 中。</p><p>判断按钮是否展示是写了一个公用方法 <code>checkPermission</code> ，没有用指令是因为无法适用于所有组件。</p><p>将提前设置好的 <code>唯一键</code> 传入方法，就可以从vuex里 <code>store.getters.buttons</code> 拿到所有按钮权限，对比后返回 <code>true 或 false</code>，来控制按钮的展示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入方法 --&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; checkPermission &#125; <span class="keyword">from</span> <span class="string">'@/utils/permissions'</span></span><br><span class="line"></span><br><span class="line">&lt;!-- data中定义变量 --&gt;</span><br><span class="line">addEnable: checkPermission(<span class="string">'system:role:add'</span>)</span><br><span class="line"></span><br><span class="line">&lt;!-- v-<span class="keyword">if</span>判断 --&gt;</span><br><span class="line">&lt;el-button v-<span class="keyword">if</span>=<span class="string">"addEnable"</span>&gt;添加角色&lt;<span class="regexp">/el-button&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;记录写后台管理系统时的一些想法和组件的二次封装，项目初期参考的是&lt;a href=&quot;https://github.com/PanJiaChen&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;花裤衩&lt;/a&gt;大神的&lt;a href=&quot;https://github.com/PanJiaChen/vue-element-admin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-element-admin&lt;/a&gt;，后期根据业务进行了一些修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Yu-Lxy/element-admin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目Github地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>第一次使用mongoDB的记录</title>
    <link href="http://yoursite.com/2020/09/04/mongo/"/>
    <id>http://yoursite.com/2020/09/04/mongo/</id>
    <published>2020-09-04T07:30:15.000Z</published>
    <updated>2020-09-04T10:00:05.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个 <code>vue+express+mongodb</code> 的小demo，实现了列表的增删查，以及简单的分页功能。<br><a href="https://github.com/Yu-Lxy/Daily_practice/tree/master/mongo" target="_blank" rel="noopener">Github项目地址</a></p><a id="more"></a><h2 id="mongo命令行操作"><a href="#mongo命令行操作" class="headerlink" title="mongo命令行操作"></a>mongo命令行操作</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入mongo命令行</span></span><br><span class="line"><span class="selector-tag">mongo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有数据库</span></span><br><span class="line"><span class="selector-tag">show</span> <span class="selector-tag">dbs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换/创建数据库,当创建一个集合(table)的时候会自动创建当前数据库</span></span><br><span class="line"><span class="selector-tag">use</span> <span class="selector-tag">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="selector-tag">db</span>.表名<span class="selector-class">.find</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件查询</span></span><br><span class="line"><span class="selector-tag">db</span>.表名<span class="selector-class">.find</span>(&#123;<span class="attribute">price</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入(insertOne/insertMany/save)</span></span><br><span class="line"><span class="selector-tag">db</span>.表名<span class="selector-class">.insertOne</span>(&#123;<span class="attribute">name</span>: <span class="string">'苹果'</span>, <span class="attribute">price</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="selector-tag">db</span>.表名<span class="selector-class">.update</span>(&#123; <span class="attribute">name</span>: <span class="string">'苹果'</span> &#125;, &#123; $<span class="attribute">set</span>: &#123; <span class="attribute">price</span>: <span class="number">6</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除(deleteOne/deleteMany/remove)</span></span><br><span class="line"><span class="selector-tag">db</span>.表名<span class="selector-class">.updateOne</span>(&#123; <span class="attribute">name</span>: <span class="string">'苹果'</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><blockquote><p>mongoDB的基本操作</p></blockquote><ol><li><p>连接mongoDB</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接URL</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">url</span> = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库名</span></span><br><span class="line"><span class="keyword">const</span> dbName = <span class="string">'test'</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0.创建客户端</span></span><br><span class="line">  <span class="keyword">const</span> client = <span class="keyword">new</span> MongoClient(<span class="built_in">url</span>, &#123; <span class="attribute">useNewUrlParser</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1.连接数据库(异步) </span></span><br><span class="line">    <span class="keyword">await</span> client.connect() </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接成功'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">  client.close()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>获取数据库</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">db</span> = client.<span class="keyword">db</span>(dbName)</span><br></pre></td></tr></table></figure></li><li><p>获取表</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> col = <span class="keyword">db</span>.collection(colName)</span><br></pre></td></tr></table></figure></li></ol><p>基本操作了解后运行一下<a href="https://github.com/Yu-Lxy/Daily_practice/tree/master/mongo" target="_blank" rel="noopener">项目</a>里的代码~ 👇</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>首先安装以下<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">i</span> express path <span class="keyword">events</span> mongodb nodemon</span><br></pre></td></tr></table></figure></p><p>conf.js里设置自己的mongodb配置</p><p>数据库没数据的话先执行以下添加数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> models</span><br><span class="line">nodemon testData.js</span><br></pre></td></tr></table></figure></p><p>添加好之后ctrl+c, 再执行以下<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cd</span></span> ..</span><br><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure></p><p>打开localhost:3000能看到如下样式</p><p><img src="https://i.loli.net/2020/08/27/ALNjeIKPOY9QTHF.png" alt="image.png"></p><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p><a href="https://github.com/Yu-Lxy/Daily_practice/tree/master/mongo" target="_blank" rel="noopener">项目</a>中有一个testData.js，执行后可以插入测试数据。其中有一个 <code>mongodb.once()</code> 方法，实际上在db.js里的 <code>MongDB类</code> 中是执行了 <code>EventEmitter的once</code> 方法。events模块只提供了一个对象： <code>events.EventEmitter</code>， 其核心就是事件触发与事件监听器功能的封装，可以通过require(‘events’)来访问该模块。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter </span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventEmitter() </span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="params">num</span> =&gt;</span>  &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发:'</span> + num) </span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span>  &#123; </span><br><span class="line">  event.emit(<span class="string">'some_event'</span> , num ++ ) </span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><p><code>event.once()</code> 是只执行一次的监听，所以执行 <code>nodemon testData.js</code> 后，只触发一次连库的操作并执行回调。</p><h2 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h2><ul><li>后端get请求的参数从<code>query</code>里拿, post请求的参数从<code>body</code>里拿。</li><li><code>const page = + req.query.page</code> +号为了转Number类型。</li><li><code>.skip(n).limit(m)</code> 意为跳过n个取m个。</li><li>mongoDB插入数据时自动生成的 <code>_id</code> 是 <code>ObjectId</code> 对象类型，所以当参数作为查询条件时需要引入 <code>mongodb的ObjectID</code>，传参时调用。</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>前端小白第一次使用mongoDB的记录📝，简单小例子容易入门和理解，轻喷~ 😆</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;一个 &lt;code&gt;vue+express+mongodb&lt;/code&gt; 的小demo，实现了列表的增删查，以及简单的分页功能。&lt;br&gt;&lt;a href=&quot;https://github.com/Yu-Lxy/Daily_practice/tree/master/mongo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github项目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mongoDB" scheme="http://yoursite.com/categories/mongoDB/"/>
    
    
      <category term="mongoDB" scheme="http://yoursite.com/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>vue+koa+mysql实现一个简单的todolist</title>
    <link href="http://yoursite.com/2020/08/25/koa/"/>
    <id>http://yoursite.com/2020/08/25/koa/</id>
    <published>2020-08-25T02:41:27.000Z</published>
    <updated>2020-09-04T07:31:36.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>构建一个数据通过 <code>koa</code> 的api获取，页面通过 <code>vue</code> 渲染的前后端都有的完整demo。包括一个登陆页面和一个todolist页面的增删改查，其中用到了前端 <code>Vue框架</code> 、<code>koa</code> 提供接口、验证 <code>token</code>、<code>sequelize</code> 操作 <code>mysql</code> 等，这里记录一些关键点。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这里用到的是vue-cli2的webpack，项目创建好之后执行<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn </span><br><span class="line">yarn <span class="keyword">add </span>koa koa-router koa-logger koa-<span class="keyword">json </span>koa-<span class="keyword">bodyparser </span>nodemon vue-router element-ui axios koa-<span class="keyword">jwt </span><span class="keyword">bcrypt </span>kao-static</span><br></pre></td></tr></table></figure></p><blockquote><p>在根目录下创建server文件夹，及子文件夹</p><ul><li>config（数据库配置）</li><li>controllers（控制层，根据页面的请求选取”数据层”中相应的数据，然后返回给页面）</li><li>models（数据层，将数据库和表结构连起来）</li><li>routes（路由）</li><li>schema（表结构）</li></ul></blockquote><blockquote><p>在根目录下创建app.js作为koa的启动文件（具体代码见项目）</p></blockquote><p>后端：在控制台输入 <code>nodemon app.js</code>, 输出<code>Koa is listening in 8889</code>说明启动成功，并在8889端口监听。<br>前端：在控制台输入 <code>npm run dev</code> 后在 <code>localhost:8080</code> 可以展示前端页面。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>可以去官网下载<code>mysql</code>，我用到的可视化工具是<code>MySQLWorkbench</code></p><p>安装好后开始创建数据表。用户表：用于登录验证。待办事项表用于展示待办事项。</p><p>user表：</p><table><thead><tr><th>字段</th><th>类型</th></tr></thead><tbody><tr><td>id(用戶id)</td><td>int(自增)</td></tr><tr><td>user_name(用户名)</td><td>CHAR(50)</td></tr><tr><td>password(密码)</td><td>CHAR(128)</td></tr></tbody></table><p>—</p><p>list表：</p><table><thead><tr><th>字段</th><th>类型</th></tr></thead><tbody><tr><td>id(list的id)</td><td>int(自增)</td></tr><tr><td>user_id(用户id)</td><td>int(11)</td></tr><tr><td>content(代办内容)</td><td>CHAR(255)</td></tr><tr><td>status(代办状态)</td><td>tinyint(1)</td></tr></tbody></table><p>—</p><h2 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h2><p><code>sequelize</code> 理解为用简单的方式操作数据库的ORM框架。</p><p><code>server/schema</code> 下新建两个文件，user.js和list.js，是数据库的两张表结构，可使用sequelize-auto直接导出表结构。</p><p>在<code>server/config</code>下新建db.js, 用于初始化Sequelize和数据库的连接（具体代码见项目）</p><h2 id="JSON-WEB-TOKEN"><a href="#JSON-WEB-TOKEN" class="headerlink" title="JSON-WEB-TOKEN"></a>JSON-WEB-TOKEN</h2><p>运用了JSON-WEB-TOKEN的登录系统应该是这样的：</p><blockquote><ol><li>用户在登录页输入账号密码，将账号密码（加密后）发送请求给后端</li><li>后端验证一下用户的账号和密码的信息，如果符合就发一个token返回给客户端，如果不符合就不发送token，返回验证错误信息。</li><li>如果登录成功，客户端将token用某种方式存下来，之后要请求其他资源的时候，在请求头里带上这个token。</li><li>后端收到请求信息，先验证下token是否有效，有效则下发请求的资源，无效则返回验证错误。</li></ol></blockquote><p>通过这个token的方式，客户端和服务端之间的访问，是无状态的。也就是服务端不知道你这个用户到底在不在线，只要你发送的请求头里的token是正确的我就给你返回你想要的资源。这样能够不占用服务端的空间资源，而且如果涉及到服务器集群，如果服务器进行维护或者迁移或者需要CDN节点的分配的话，<code>无状态</code>的设计显然维护成本更低。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用法 --&gt;</span></span><br><span class="line"></span><br><span class="line">const secret = 'vue-koa-demo' // 指定密钥，这是之后用来判断token合法性的标志</span><br><span class="line"></span><br><span class="line">jwt.sign(userToken, secret) // 签发token</span><br><span class="line"></span><br><span class="line">jwt.decode(token) // 解析token</span><br></pre></td></tr></table></figure><h2 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h2><p>md5加密容易被破解，所以准备采用<code>bcrypt</code>的加密方式，全部走后端加密。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证密码是否正确</span></span><br><span class="line">bcrypt.compareSync(data<span class="selector-class">.password</span>, userInfo.password)</span><br></pre></td></tr></table></figure></p><h2 id="Token的发送与验证"><a href="#Token的发送与验证" class="headerlink" title="Token的发送与验证"></a>Token的发送与验证</h2><p>在全局发送请求<code>Header</code>上加入<code>Authorization</code>属性， 值是<code>Bearer token值</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue<span class="selector-class">.prototype</span>.<span class="variable">$http</span><span class="selector-class">.defaults</span><span class="selector-class">.headers</span><span class="selector-class">.common</span>[<span class="string">'Authorization'</span>] = <span class="string">'Bearer '</span> + token</span><br></pre></td></tr></table></figure></p><p>/api/* 都需要走token验证<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">koa</span><span class="selector-class">.use</span>(<span class="string">"/api"</span>,jwt(&#123;<span class="attribute">secret</span>: <span class="string">'vue-koa-demo'</span>&#125;),api.routes()) <span class="comment">// 所有走/api/打头的请求都需要经过jwt中间件的验证。secret密钥必须跟我们当初签发的secret一致</span></span><br></pre></td></tr></table></figure></p><h2 id="Koa-serve静态资源"><a href="#Koa-serve静态资源" class="headerlink" title="Koa serve静态资源"></a>Koa serve静态资源</h2><p>项目<code>npm run dev</code>打包后<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serve = <span class="keyword">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(serve(path.join(__dirname, <span class="string">'dist'</span>))) <span class="comment">// 将webpack打包好的项目目录作为Koa静态文件服务的目录</span></span><br></pre></td></tr></table></figure></p><p>这样不用启前端项目，localhost:8889就可以访问打包好的静态资源页面。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>这是一个前后端都有的完整小demo，结构清晰简单的小东西更容易理解和入门，完整项目<a href="https://github.com/Yu-Lxy/Daily_practice/tree/master/koa" target="_blank" rel="noopener">Github地址</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;构建一个数据通过 &lt;code&gt;koa&lt;/code&gt; 的api获取，页面通过 &lt;code&gt;vue&lt;/code&gt; 渲染的前后端都有的完整demo。包括一个登陆页面和一个todolist页面的增删改查，其中用到了前端 &lt;code&gt;Vue框架&lt;/code&gt; 、&lt;code&gt;koa&lt;/code&gt; 提供接口、验证 &lt;code&gt;token&lt;/code&gt;、&lt;code&gt;sequelize&lt;/code&gt; 操作 &lt;code&gt;mysql&lt;/code&gt; 等，这里记录一些关键点。&lt;/p&gt;
    
    </summary>
    
      <category term="koa" scheme="http://yoursite.com/categories/koa/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>try catch能捕获到哪些JS异常</title>
    <link href="http://yoursite.com/2020/08/04/tryCatch/"/>
    <id>http://yoursite.com/2020/08/04/tryCatch/</id>
    <published>2020-08-04T01:50:45.000Z</published>
    <updated>2020-09-04T02:00:54.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写代码时经常会用到 <code>try catch</code>，防止一些JS报错，导致页面挂掉。那么到底哪些JS异常能被捕获到呢？</p></blockquote><a id="more"></a><blockquote><p><strong>简单解释就是：在报错的时候，线程执行已经进入 <code>try catch</code> 代码块，并且处在 <code>try catch</code> 里，才能被捕捉到。</strong>（之前，之后都无法捕捉异常）</p></blockquote><ul><li><h6 id="下面三个小栗子，解释一下-try-catch-的前中后"><a href="#下面三个小栗子，解释一下-try-catch-的前中后" class="headerlink" title="下面三个小栗子，解释一下 try catch 的前中后"></a>下面三个小栗子，解释一下 <code>try catch</code> 的前中后</h6></li></ul><p>🌰 例子1：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a(</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Unexpected token &#125;</span><br></pre></td></tr></table></figure></p><p><em>例子1</em> 语法异常（SyntaxError），因为语法异常是在语法阶段就报错了，所以线程还没进入 <code>try catch</code> 代码块，就捕获不到异常。</p><p>🌰 例子2：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function d () &#123;a.b&#125;</span><br><span class="line">try &#123;</span><br><span class="line">   d()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">   console.log('error', e)</span><br><span class="line">&#125;</span><br><span class="line">// output</span><br><span class="line"><span class="keyword">error </span>ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p><p><em>例子2</em> 报错的时机，是代码执行进入了 <code>try catch</code> ，执行 d 方法的时候，线程执行处在 <code>try</code> 里面，所以能捕捉到。</p><p>🌰 例子3：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   function d () &#123;a.b&#125;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">   console.log('error', e)</span><br><span class="line">&#125;</span><br><span class="line">d()</span><br><span class="line">// output</span><br><span class="line"><span class="keyword">error </span>ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p><p><em>例子3</em> 方法定义在 <code>try catch</code> 代码块里，但是执行方法在 <code>try catch</code> 外，执行 d 方法的时候报错，此时 try catch 已经执行完成，所以无法捕捉异常。</p><p>三个例子之后应该能理解怎样的JS异常可以被捕获了，但是在我们用 <code>promise</code> 的时候发现相对于外部的 <code>try catch</code> ，Promise 没有异常！</p><h3 id="promise-amp-try-catch"><a href="#promise-amp-try-catch" class="headerlink" title="promise &amp; try catch"></a>promise &amp; try catch</h3><p>🌰 例子4：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    a.b</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>(v)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">ReferenceError</span>: a is not defined</span><br></pre></td></tr></table></figure></p><p><em>例子4</em> 线程在执行a.b的时候，适时向属于同步执行，<code>try catch</code> 并未执行完成，为什么捕获不到异常呢？</p><p>事实上，<strong>Promise 的异常都是由 reject 和 Promise.prototype.catch 来捕获</strong>，不管是同步还是异步。</p><p>核心原因是因为 <code>Promise</code> 在执行回调中都用 <code>try catch</code> 包裹起来了，其中所有的异常都被内部捕获到了，并未往上抛异常，所以异常都不会被外层的 <code>try catch</code> 捕捉。</p><p>🌰 例子5：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'报错了'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> a()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">error 报错了</span><br></pre></td></tr></table></figure></p><p>为什么 <em>例子5</em> 的异常能被 <code>catch</code> 捕获到呢，因为报错的时候，线程执行已经进入了 <code>try catch</code> 代码块，并且异常由 reject 抛出，自然可以捕获到。</p><p> ###总结：</p><blockquote><p><strong>1. 在报错的时候，线程执行已经进入 <code>try catch</code> 代码块，并且处在 <code>try catch</code> 里，才能被捕捉到。</strong></p></blockquote><blockquote><p><strong>2. 不要用 <code>try catch</code> 包裹 <code>Promise</code>，我们只需要给 <code>Promise</code> 增加 Promise#catch 就 OK 了</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写代码时经常会用到 &lt;code&gt;try catch&lt;/code&gt;，防止一些JS报错，导致页面挂掉。那么到底哪些JS异常能被捕获到呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>EventLoop 的简单理解</title>
    <link href="http://yoursite.com/2020/07/28/eventLoop/"/>
    <id>http://yoursite.com/2020/07/28/eventLoop/</id>
    <published>2020-07-28T02:13:09.000Z</published>
    <updated>2020-09-04T02:15:23.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="EventLoop是什么"><a href="#EventLoop是什么" class="headerlink" title="EventLoop是什么"></a>EventLoop是什么</h3><blockquote><p>一个循环 每次循环叫tick 每次循环的代码叫task</p></blockquote><ul><li>V8引擎单线程无法同时干两件事</li><li>文件读取、网络IO缓慢且具有不确定性</li><li>要通过异步回调方式处理又称为异步IO</li><li>先同步再异步 异步放入队列等同步完成后再执行 每次循环叫一个tick(process.nextTick())</li></ul><a id="more"></a><h3 id="异步任务的区分"><a href="#异步任务的区分" class="headerlink" title="异步任务的区分"></a>异步任务的区分</h3><p>microtasks(微任务)：</p><blockquote><p>唯一，整个事件循环中仅存在一个；执行为同步，同一个事件循环中的microtasks会按队列顺序串行执行完毕</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe</li><li>MutationObserver</li></ul></blockquote><p>macrotask(宏任务)：</p><ul><li>setTimeout</li><li>serInterval</li><li>setImmediate</li><li>I/O</li><li>UI渲染</li></ul><blockquote><p>先执行微任务 再执行宏任务</p></blockquote><p>如果遇到async的代码 await后面的程序就挂起 类似于微任务 等到后面的同步任务执行完了再执行</p><p>最后上一个小栗子🌰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;))</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'promise then ...'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"fun start"</span>)</span><br><span class="line">  <span class="keyword">const</span> aa = <span class="keyword">await</span> <span class="number">1</span> <span class="comment">// 到这里挂起，后面先不执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"fun end"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout 放入event table中 1秒后将回调函数放入宏任务的event queue中</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout ...'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick ...'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console ...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">resolve</span><br><span class="line">fun start</span><br><span class="line"><span class="built_in">console</span> ...</span><br><span class="line">nextTick ...</span><br><span class="line">promise then ...</span><br><span class="line">fun end</span><br><span class="line">setTimeout ...</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;EventLoop是什么&quot;&gt;&lt;a href=&quot;#EventLoop是什么&quot; class=&quot;headerlink&quot; title=&quot;EventLoop是什么&quot;&gt;&lt;/a&gt;EventLoop是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个循环 每次循环叫tick 每次循环的代码叫task&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;V8引擎单线程无法同时干两件事&lt;/li&gt;
&lt;li&gt;文件读取、网络IO缓慢且具有不确定性&lt;/li&gt;
&lt;li&gt;要通过异步回调方式处理又称为异步IO&lt;/li&gt;
&lt;li&gt;先同步再异步 异步放入队列等同步完成后再执行 每次循环叫一个tick(process.nextTick())&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue+vue-ueditor-wrap+秀米</title>
    <link href="http://yoursite.com/2019/09/03/xiumi/"/>
    <id>http://yoursite.com/2019/09/03/xiumi/</id>
    <published>2019-09-03T09:44:15.000Z</published>
    <updated>2020-09-04T01:53:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>我们的项目中使用的是ueditor+秀米的富文本编辑器，github上的大神做了一个基于vue的ueditor的组件，能够实现双向数据绑定，可以不用费劲的getContent、setContent。就决定用这个组件 ——  <a href="https://github.com/HaoChuan9421/vue-ueditor-wrap" target="_blank" rel="noopener">vue-ueditor-wrap</a>    。so~  vue+vue-ueditor-wrap+秀米. 开始吧 ⤵︎</p><a id="more"></a><p><strong>一：去ueditor官网下载官方源码</strong> </p><ol><li><p><a href="https://ueditor.baidu.com/website/download.html" target="_blank" rel="noopener">https://ueditor.baidu.com/website/download.html</a></p></li><li><p>下载完成后，放到你的Vue项目里static下并命名为UEditor。</p></li></ol><p><strong>二：安装vue-ueditor-wrap</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-ueditor-wrap</span><br></pre></td></tr></table></figure><p><strong>三：引入并使用</strong> </p><ol><li><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="comment">// 引入ueditor的依赖文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/ueditor.config'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/ueditor.all.min.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/lang/zh-cn/zh-cn.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../static/UEditor/ueditor.parse.min.js'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">  &lt;!--数据绑定--&gt;</span><br><span class="line">    &lt;vue-ueditor-wrap v-model=<span class="string">"msg"</span> /&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import VueUeditorWrap from 'vue-ueditor-wrap' /</span><span class="regexp">/ 引入vue-ueditor-wrap</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'HelloWorld',</span></span><br><span class="line"><span class="regexp">  components: &#123;</span></span><br><span class="line"><span class="regexp">    VueUeditorWrap/</span><span class="regexp">/注册组件</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      msg: 'Welcome to Your Vue.js App'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些完成后，你就可以看到一个初始化好的<code>ueditor</code>了，并且可以很方便的绑定想要的数据 ?<br>接入<strong>秀米</strong>的童鞋继续向下看?</p><p><strong>四：在ueditor基础上接入秀米</strong></p><p>秀米提供：<a href="http://hgs.xiumi.us/uedit/" target="_blank" rel="noopener">秀米图文排版UEditor插件示例</a></p><ol><li><p>在你的index.html中引用 <code>http://xiumi.us/connect/ue/xiumi-ue-dialog-v5.js</code> 和 <code>http://xiumi.us/connect/ue/xiumi-ue-v5.css</code> 也可以下载文件后放在UEditor目录下引入本地文件，这样方便修改。（我是下载后引入本地的）如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"static/UEditor/xiumi-ue-v5.css"</span>&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"static/UEditor/xiumi-ue-dialog-v5.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>下载文件 <code>http://xiumi.us/connect/ue/xiumi-ue-dialog-v5.html</code> 和 <code>http://hgs.xiumi.us/uedit/dialogs/internal.js</code> 放在你的UEditor目录下。</p></li><li><p>修改<code>UEditor</code>的配置（ueditor.config.js），第414行左右：将section:[] 改为section:[‘class’, ‘style’]，避免ueditor修改秀米的格式信息，造成排版错误。</p></li><li><p>在<code>xiumi-ue-dialog-v5.js</code>中把<code>iframeUrl</code>改为本地秀米H5的路径，如果你都是按照以上步骤进行那么路径将是<code>/static/UEditor/xiumi-ue-dialog-v5.html</code>，如果不是的话要按你自己的路径。</p></li></ol><p>到这里就是可以正常使用秀米并且有着双向数据绑定的ueditor啦。<br>图片上传相关功能需要后台小哥哥的协助。<br>其余与秀米的对接可以参考<a href="http://ent.xiumi.us/" target="_blank" rel="noopener">与秀米对接</a><br>还是有疑问的小盆友可以下载我上传的<a href="https://github.com/Yu-Lxy/vue-ueditor-wrap-xiumi" target="_blank" rel="noopener">demo</a>，希望可以帮助到你😜</p><p>这是接好后的样纸：<br><img src="/2019/09/03/xiumi/1599127298698.jpg" alt="秀米"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的项目中使用的是ueditor+秀米的富文本编辑器，github上的大神做了一个基于vue的ueditor的组件，能够实现双向数据绑定，可以不用费劲的getContent、setContent。就决定用这个组件 ——  &lt;a href=&quot;https://github.com/HaoChuan9421/vue-ueditor-wrap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-ueditor-wrap&lt;/a&gt;    。so~  vue+vue-ueditor-wrap+秀米. 开始吧 ⤵︎&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://yoursite.com/2019/03/01/buildHexo/"/>
    <id>http://yoursite.com/2019/03/01/buildHexo/</id>
    <published>2019-03-01T09:32:15.000Z</published>
    <updated>2020-09-04T02:35:57.146Z</updated>
    
    <content type="html"><![CDATA[<p>第一次看到这种类型的博客就赶脚逼格很高的样纸 😎</p><p>后来试着搭起来觉得并不困难 ☁️</p><p>简单来说hexo就是一个静态页面生成和创建的工具</p><p>这篇教你搭建一个自己的hexo博客 👉</p><a id="more"></a><h3 id="我的搭建步骤有以下："><a href="#我的搭建步骤有以下：" class="headerlink" title="我的搭建步骤有以下："></a>我的搭建步骤有以下：</h3><ul><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>生成SSH添加到GitHub</li><li>将hexo部署到GitHub</li></ul><h3 id="1-安装git和node"><a href="#1-安装git和node" class="headerlink" title="1.安装git和node"></a>1.安装git和node</h3><p>git和node是必备条件, 可以戳：<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰大神的git教程</a><br><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">下载node</a></p><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>git和node安好之后，接下来就是安hexo了<br>1.可以先新建一个文件夹，例🌰:我的是myBlog<br>进到这个文件夹内，打开命令行<br>2.Windows的小伙伴可以直接用 <code>npm install -g hexo</code><br>mac的小伙伴需要用 <code>sudo npm install --unsafe-perm --verbose -g hexo</code><br>完成之后可以 <code>hexo -v</code> 查看hexo版本<br>3.接下来初始化hexo <code>hexo init</code><br>完成之后会在myBlog生成以下文件：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>node_modules：</td><td>是依赖包</td></tr><tr><td>public：</td><td>生成的静态文件，这个目录最终会发布到服务器</td></tr><tr><td>scaffolds：</td><td>命令生成文章等的模板</td></tr><tr><td>source：</td><td>编写的markdown文件，_drafts草稿文件，_posts发布的文章</td></tr><tr><td>themes：</td><td>主题</td></tr><tr><td>_config.yml：</td><td>整个博客的配置</td></tr><tr><td>package.json：</td><td>项目所需模块项目的配置信息</td></tr></tbody></table><p>我们正常使用，修改最多的源码是 <code>_config.yml</code> 文件，不管是博客的基础配置，还是模板，都是修改这个文件。<br><code>source</code> 是我们日常写文章要用的目录，是我们日常操作的文件夹。<br>如果要修改主题模板，就需要操作 <code>themes</code>.</p><p>4.接下来<br><code>hexo g</code><br><code>hexo s</code><br>就可以在本地 <code>http://localhost:4000</code> 预览了<br><code>ctrl+c</code> 或是 <code>control+c</code> 关闭本地服务</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>没有github账号需要先注册一个哦<br>有账号就新建一个库：<br><img src="/2019/03/01/buildHexo/hexo1.jpg" alt="Create a new repository"><br>建一个和你的username一样名字的库，比如我的就是这样：<br><img src="/2019/03/01/buildHexo/hexo2.jpg" alt><br>点击create repository</p><h3 id="生成SSH添加到GitHub-mac"><a href="#生成SSH添加到GitHub-mac" class="headerlink" title="生成SSH添加到GitHub(mac)"></a>生成SSH添加到GitHub(mac)</h3><p>1.检查是否已经存在SSH Key<br>打开电脑终端，输入 <code>ls -al ~/.ssh</code><br>2.如果终端出现文件id_rsa.pub 或 id_dsa.pub，则表示该电脑已经存在SSH Key，此时可继续输入<br><code>cat ~/.ssh/id_rsa.pub</code><br>复制接下来显示出来的一大串内容<br>3.如果终端未出现id_rsa.pub 或 id_dsa.pub文件，表示该电脑还没有配置SSH Key，此时需要输<br><code>ssh-keygen -t rsa -C &quot;your_full_name@xxxxx.com&quot;</code><br>连续回车即可，也可能会让你输入密码，密码就是你的开机密码<br>创建完成后按照第二步操作复制就行啦<br>这时候去到GitHub的setting<img src="/2019/03/01/buildHexo/hexo3.jpg" alt><br>再点击SSH and GPG keys<img src="/2019/03/01/buildHexo/hexo4.jpg" alt><br>点击New SSH key之后吧你刚刚复制的一串key粘在这里面 点击Add SSH key就ok啦<br><img src="/2019/03/01/buildHexo/hexo5.jpg" alt></p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>完成这一步就可以把你的hexo部署到github上辣<br>1.首先在你的项目文件下找到 <code>_config.yml</code> 进去找到<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/YourgithubName/YourgithubName.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p><p>把这个地址改成你专属的，比如我的是：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">repo:</span> <span class="string">https:</span><span class="comment">//github.com/Yu-Lxy/Yu-Lxy.github.io</span></span><br></pre></td></tr></table></figure></p><p>*注：这里有个坑🕳，一定要在冒号后面加一个空格，不然 <code>hexo d</code> 的时候会没有反应</p><p>2.需要安装deploy-git,也就是部署的命令,这样你才能用命令部署到GitHub:<br><code>npm install hexo-deployer-git --save</code><br>3.然后<br><code>hexo g</code><br><code>hexo d</code><br>输入 <code>http://yourname.github.io</code> 就能看到你的hexo咯~😆</p><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次看到这种类型的博客就赶脚逼格很高的样纸 😎&lt;/p&gt;
&lt;p&gt;后来试着搭起来觉得并不困难 ☁️&lt;/p&gt;
&lt;p&gt;简单来说hexo就是一个静态页面生成和创建的工具&lt;/p&gt;
&lt;p&gt;这篇教你搭建一个自己的hexo博客 👉&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
